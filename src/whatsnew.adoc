[[sec:whatsnew]]
== What's New in Ion 1.1

We will go through a high-level overview of what is new and different in Ion 1.1 from Ion 1.0 from an implementer's
perspective.

=== Motivation

Ion 1.1 has been designed to address some of the trade-offs in Ion 1.0 to make it suitable for a wider range of
applications.  Ion 1.1 now makes length prefixing of data optional, but also makes the interning of symbolic tokens
optional as well.  This allows for applications that write data more than they read data or are constrained by the
writer in some way to have more flexibility.  Data density is another motivation.  Certain encodings (e.g., timestamps,
integers) have been made more compact and efficient, but more significantly, macros and templates now enable
applications to have very flexible interning of their data's structure.  In aggregate, data transcoded from Ion 1.0 to
Ion 1.1 should be more compact.

=== Backwards Compatibility

Ion 1.1 is backwards compatible to Ion 1.0.  Backwards compatibility is defined as being able to _parse_ Ion 1.0 encoded
data *and* ensuring that any data model values produced by Ion 1.1 that are _not_ system values must be representable in
Ion 1.0.  To wit, any data that can be produced and read by an application in Ion 1.1 must have an equivalent
representation in Ion 1.0.

IMPORTANT: *_Discussion_*: Is this statement too weak? Specifically, should we be attempting to "fill in the holes" in
the Ion data model around system values?  Should we require that Ion 1.1 implementations _produce_ Ion 1.0 data?

Ion 1.1 is *not* required to preserve Ion 1.0 binary encoding in Ion 1.1 encoding contexts (i.e., the type codes and
lower-level encodings are not preserved in the new version).  The Ion Version Marker (IVM) is used to denote the
different versions of the syntax.  Ion 1.1 does retain text compatibility with Ion 1.0 in that the changes are a strict
superset of the grammar, however due to the updated system symbol table, symbol IDs referred to using the `$n` syntax
for symbols beyond the 1.0 system symbol table are not be compatible.

[[sec:whatsnew-text]]
=== Text Syntax Changes

Ion 1.1 text *must* use the `$ion_1_1` version marker at the top-level of the data stream or document.

The only syntax change for the text format is the *encoding expression* (*e-expression*) syntax which allows for the
invocation of macros in the data stream. This syntax is grammatically similar to s-expressions, except that these
expressions are opened with `(:` and closed with `)`.  For example, `(:a 1 2)` would expand the macro named `a` with the
arguments `1` and `2`. See the <<sec:whatsnew-eexp, Macros, Templates, and Encoding-Expressions>> section for details.

This syntax is allowed anywhere an Ion value is allowed:

.Figure {counter:figure-number}. E-expression Examples
[source,plain,%unbreakable]
----
(:foo 1 2)
[1, 2, (:bar 3 4)]
(cons a (:baz b))
{c: (:bop d)}
----

E-expressions are also grammatically allowed in the field name position of a struct and when used there, indicate that
the expression should expand to a struct value that is merged into the enclosing struct:

.Figure {counter:figure-number}. E-Expression in field position of struct.
[source,plain,%unbreakable]
----
{
    a:1,
    b:2,
    (:foo 1 2),
    c: 3,
}
----

In the above example, the e-expression `(:foo 1 2)` must evaluate into a struct that will be merged between the `b`
field and the `c` field.  If it does not evaluate to a struct, then the above is an error.

[[sec:whatsnew-bin]]
=== Binary Encoding Changes

Ion 1.1 binary encoding reorganizes the type descriptors to support compact e-expressions, make certain encodings
more compact, and certain lower priority encodings marginally less compact.  The IVM for this encoding is the octet
sequence `0xE0 0x01 0x01 0xEA`.

[[sec:whatsnew-inline-symbols]]
==== Inlined Symbolic Tokens

IMPORTANT: *_Discussion_*: Should we call this something else (e.g., _non-interned_)?

In Ion 1.0, symbol values, field names, and annotations are required to be encoded using a symbol ID in the local symbol
table.  For some use cases (e.g., as write once, read maybe logs) this creates a burden on the writer and may not
actually be efficient for an application.  Ion 1.1 introduces optional binary syntax for encoding inline UTF-8 sequences
for these tokens which can allow an encoder to have flexibility in whether or not to add a given symbolic token to the
symbol table.

Ion text requires no change for this feature as it already had inline symbolic tokens without using the local symbol
table.  Ion text also has compatible syntax for representing the local symbol table and encoding of symbolic tokens with
their position in the table (i.e., the `$id` syntax).

[[sec:whatsnew-delimited]]
==== Delimited Containers

In Ion 1.0, all data is length prefixed.  While this is good for optimizing the reading of data, it requires an Ion
encoder to buffer any data in memory to calculate the data's length.  Ion 1.1 introduces optional binary syntax to allow
containers to be encoded with an end marker.

==== Low-level Encoding Changes

The `VarUInt` and `VarInt` encodings have been changed to put their continuation bits before the content.  This is
similar in structure to UTF-8 encoding.  `VarInt` has also been changed to be a two's complement representation rather
than a signed magnitude representation.  Benchmarks have shown that these encoding changes to be about 15% faster than
the Ion 1.0 version of the encoding.

The `Int` encoding has also been changed to be two's complement over its original signed magnitude representation.

IMPORTANT: *_Discussion_*: Should we call these new low-level encodings something else to not confuse them with their
1.0 counterparts?  If so, what should we call them?

A new primitive encoding type, called `VarSym` has been introduced to flexibly encode symbol IDs and symbolic tokens
with inline text.  This encoding is structurally identical to `VarInt` but is used to encode symbolic tokens that could
be either a symbol ID or a length of the UTF-8 octets that follow.

* Positive integers represent symbol IDs.

* Negative integers represent a length of UTF-8 octets to follow.

* Zero is treated specially.  Specifically, A `VarSym` encoded as `0x00` indicates that a special control opcode
follows. The following table specifies the control opcodes, all other opcodes are illegal.

[%header,%unbreakable,cols="1,1"]
|===

| Control Opcode
| Description

| `0x0_` - `0x4_`, `0xE1`, `0xF0`
| E-expression follows.  This is only valid when a field name in a struct is expected.

| `0x70`
| Represents `$0`.

| `0x80`
| Represents empty inline text (i.e., `''`).

| `0xAD`
| Ends a delimited struct.  This is only valid when a field name in a _delimited_ struct is expected.

|===

The padded representations of zero in `VarSym` (e.g., `0x80 0x00`, `0xC0 0x00 0x00`) all mean `$0`.

NOTE: The _control opcode_ is designed to parallel the Ion 1.1 _type opcodes_ which is why they might seem, out of that
context, arbitrary.

==== Type Encoding Changes

All Ion types use the new low-level encodings as specified in the previous section.  Many of the opcodes used in Ion 1.0
have been re-organized primarily to make e-expressions compact.

Typed `null` values are now all encoded with two bytes with the `0xAE` opcode.  Lists and s-expressions have two
encodings, the Ion 1.0 length prefixed encoding and the new delimited form that end with the `0xAD` end opcode.  Struct
values have three encodings, the Ion 1.0 length prefixed encoding, the length prefixed encoding using `VarSym` to encode
field names (allowing for inline symbol text), and the delimited form that encodes its field names with `VarSym` (there
is no delimited form with Ion 1.0 encoding of field names).  Symbol values have two encodings, one is the Ion 1.0
encoding with the symbol ID, and the other one is structurally identical to the encoding of strings, which are used for
symbols with inline text.

Annotated values no longer have an outer length container.  They are now encoded with an opcode that specifies a single
annotation with value following; an opcode that specifies two annotations with a value following; and finally, an opcode
that specifies a variable length of annotations followed by a value.  The latter encoding is similar to how Ion 1.0
annotations are encoded with the exception that there is no outer length.

IMPORTANT: *_Discussion_*: Should we provide an op-code for length prefixing the entire annotation?  If so, where should
it go? E.g, make the variable length SID based annotations support this.

Integers now use an `Int` sub-field instead of the Ion 1.0 encoding using sign magnitude (with two opcodes).

Decimals are structurally identical to their Ion 1.0 counterpart with the exception of the negative zero coefficient.
The Ion 1.1 `VarInt` encoding is two's complement, so negative zero cannot be encoded directly with it.  Instead an
encoding opcode is allocated specifically for encoding negative zero decimals.

Timestamps no longer encode their sub-field components as octet-aligned fields.  The Ion 1.1 format uses a packed bit
encoding and has a biased form (encoding the year field as an offset from 1970) to make common encodings of timestamp
easily fit in a 64-bit word for microsecond and nanosecond precision (with UTC offset or unknown UTC offset).
Benchmarks have shown this new encoding to be 59% faster to encode and 21% faster to decode.  A non-biased, arbitrary
length timestamp with packed bit encoding is defined for cases outside of the common cases.

==== Encoding Expressions in Binary

E-expressions in binary are encoded with an opcode that encodes the _macro identifier_ or an opcode that specifies a
`VarUInt` for the macro identifier.  This is followed by the encoding of the arguments to the e-expression.  The macro's
definition statically determines how the arguments are to be laid out.  When all arguments for a macro are of fixed
cardinality the parameters are layed out with their respective encodings. An argument may be a full Ion value with
encoding opcode, or it could be a lower-level encoding (e.g., fixed width integer or `VarInt`/`VarUInt`).

[[sec:whatsnew-eexp]]
=== Macros, Templates, and Encoding-Expressions

Ion 1.1 introduces a new kind of encoding called *encoding expression* (*e-expression*).  These expressions are (in text
syntax) similar to s-expressions, but they are not part of the data model and are _evaluated_ into one or more Ion
values (called a _stream_) which enable compact representation of Ion data.  E-expressions represent the invocation of
either system defined or user defined *macros* with arguments that are either themselves e-expressions, value literals,
or container constructors (list, sexp, struct syntax containing e-expressions) corresponding to the formal parameters of
the macro's definition.  The resulting stream is then expanded into the resulting Ion data model.

At the top level, the stream becomes individual top-level values.  Consider for illustrative purposes an e-expression
`(:values 1 2 3)` that evaluates to the stream `1`, `2`, `3` and `(:void)` that evaluates to the empty stream.  In the
following examples, `values` and `void` are the names of the macros being invoked and each line is equivalent.

.Figure {counter:figure-number}. Top-level E-expressions
[source,plain,%unbreakable]
----
a (:values 1 2 3) b (:void) c
a 1 2 3 b c
----

Within a list or s-expression, the stream becomes additional child elements in the collection.

.Figure {counter:figure-number}. E-expressions in lists
[source,plain,%unbreakable]
----
[a, (:values 1 2 3), b, (:void), c]
[a, 1, 2, 3, b, c]
----

.Figure {counter:figure-number}. E-expressions in s-expressions
[source,plain,%unbreakable]
----
(a (:values 1 2 3) b (:void) c)
(a 1 2 3 b c)
----

Within a struct at the field name position, the resulting stream must contain structs and each of the fields in those
structs become fields in the enclosing struct (the value portion is not specified); at the value position, the resulting
stream of values becomes fields with whatever field name corresponded before the e-expression (empty stream elides the
field all together).  In the following examples, let us define `(:struct c 5)` that evaluates to a single struct `{c:
5}`.

.Figure {counter:figure-number}. E-expressions in structs
[source,plain,%unbreakable]
----
{a: (:values 1 2 3), b: 4, (:struct c 5), d: 6, e: (:void)}
{a: 1, a: 2, a: 3, b: 4, c: 5, d: 6}
----

==== Encoding Context and Modules

In Ion 1.0, there is a single _encoding context_ which is the local symbol table.  In Ion 1.1, the _encoding context_
becomes the following:

* The local symbol table which is a list of strings.  This is used to encode/decode symbolic tokens.

* The local macro table which is a list of macros.  This is used to reference macros that can be invoked by
e-expressions.

* A mapping of a string name to *module* which is an organizational unit of symbol definitions and macro definitions.
  Within the encoding context, this name is unique and used to address a module's contents either as the list of symbols
  to install into the local symbol table, the list of macros to install into the local macro table, or to qualify the
  name of a macro in a text e-expression or the definition of a macro.

The *module* is a new concept in Ion 1.1.  It contains:

* A list of of strings representing the symbol table of the module.

* A list of macro definitions.

Modules can be imported from the catalog (they subsume shared symbol tables), but can also be defined locally.  Modules
are referenced as a group to allocate entries in the local symbol table and local macro table (e.g., the local symbol
table is initially, implicitly allocated with the symbols in the `$ion` module).

Ion 1.1 introduces a new system value for the encoding context (see the *_TBD_* section for details.)

.Figure {counter:figure-number}. Encoding Context in Ion Text
[source,plain,%unbreakable]
----
// TODO - Example
----

IMPORTANT: This is still being actively worked and is provisional.

==== Macro Definitions

Macros can be defined by a user either directly in a local module within an encoding context or in a shared module
defined externally (i.e., shared module).  A macro has a name which must be unique in a module *or* it may have no name.

Ion 1.1 defines a list of _system macros_ that are built-in in the module named `$ion`.  Unlike the system symbol table,
which is always installed and accessible in the local symbol table, the system macros are both always accessible to
e-expressions and not installed in the local macro table by default (unlike the local symbol table).

In Ion binary, macros are always addressed in e-expressions by the offset in the local macro table.  System macros may
be addressed by the system macro identifier using a specific encoding op-code.  In Ion text, macros may be addressed by
the offset in the local macro table (mirroring binary), its name if its name is unambiguous within the local encoding
context, or by qualifying the macro name/offset with the module name in the encoding context.  An e-expression can
_only_ refer to macros installed in the local macro table or a macro from the system module.  In text, an e-expression
referring to a system macro that *is not* installed in the local macro table, must use a qualified name with the `$ion`
module name.

For illustrative purposes let's consider the module named `foo` that has a macro named `bar` at offset 5 installed at
the begining of the local macro table.

.Figure {counter:figure-number}. E-expressions name resolution in text
[source,plain,%unbreakable]
----
// allowed if there are no ther macros named 'bar' 
(:bar)
// fully qualified by module--always allowed
(:foo:bar)
// by local macro table offset
(:5)
// system macros are always addressable by name--in binary this would be a different offset with a different opcode
(:$ion:void)
----

==== Template Definition Language

User defined macros are defined by their *template* which defines how they are invoked and what stream of data they
evaluate to.  This template is defined using a domain specific language with s-expressions.  A template defines a fixed
set of zero or more parameters that it can accept.  These parameters each have their own cardinality which can be
specified as _required_ (exactly one), _optional_ (zero or one), _zero or more_, and _one or more_.  Furthermore the
template defines what type of argument can be accepted by each of these parameters:

* Specific type(s) of Ion value.

* Lower-level binary data (e.g. fixed width integers or `VarUInt`) for efficient encodings of the e-expressions in
binary.

* Specific e-expressions to allow for structural composition of macros and efficient encoding in binary.

The template defintion includes a *template expression* that make up the body of the template (see the *_TBD_* section
for details).  In the language, system macros, macros defined in previously defined modules in the encoding context, and
macros defined previously in the current module are accessible to be invoked with `(name ...)` syntax where `name` is
the macro to be invoked.  Certain names in the expression syntax are reserved for special forms (i.e., `quote`, `if`,
`when`, `unless`, and `each`).  When a macro name is shadowed by a special form, or is ambiguous with respect to all
macros visible, it can always be qualified with `(':module:name' ...)` syntax where `module` is the name of the module
and `name` is the offset or name of the macro.  Referring to a previously defined macro name _within_ a module may be
qualified with `(':name ...')` syntax.

INFORMATION: *_TBD_* put an easy to access example of a template definition.

==== Shared Modules

Ion 1.1 extends the concept of _shared symbol table_ to be a _shared module_.  An Ion 1.0 shared symbol table is a
shared module with no macro definitions.  A new schema for the convention of serializing shared modules in Ion are
introduced in Ion 1.1 (see the *_TBD_* section for details).  An Ion 1.1 implementation should support containing Ion
1.0 shared symbol tables and Ion 1.1 shared modules in its catalog.

=== System Symbol Table Changes

The system symbol table in Ion 1.1 adds the following symbols:

[%header,%unbreakable,cols="1,1"]
|===

| ID
| Symbol Text

| 10
| `$ion_encoding`

| 11
| `$ion_literal`

|===

System macro identifiers are namespaced separately and therefore do not have entries in the system symbol table.

IMPORTANT: These assignments are provisional.  Specifically assignments for the template definition language have not
been established.

<<<

[appendix]
=== Binary Encoding Opcodes

The following is a table of the encoding opcodes for the data format (the leading byte that indicates how the following
bytes should be decoded).

[%header,%unbreakable,cols="1,1"]
|===

| Encoding Opcode
| Description

| `0x0_`
.4+|
  E-expression with macro identifier encoded in the opcode.  The high-order two bits indicate that the lower six bits
  represent the macro identifier to expand (64 single opcode expansions).  Encoded arguments that match the expected
  parameter list follow.

| `0x1_`

| `0x2_`

| `0x3_`

| `0x4_`
| E-expression with variable length macro identifier.  The low nibble is the top four bits of the macro identifier.
  A `VarUInt` follows encoding the rest of the bits of the macro identifier which is offset from 64.  Encoded arguments that match the expected
  parameter list follow.

| `0x50` - `0x5E`
| Decimal. Length specified by low nibble.  Encoding is structurally as in Ion 1.0, but with the new `VarInt` and `Int`
  encodings for the coefficient and exponent sub-fields.  Also note that `0x5E` is a length 14 decimal and not variable
  length.  `0xF5` encodes variable length decimals. `null.decimal` is handled by `0xAE`.

| `0x5F`
| Decimal, with negative zero coefficient.  Length is specified by `VarUInt` and an exponent encoded as an `Int`
  follows.  The new encodings for `VarInt`/`Int` are not sign magnitude, so this special case is handled with the type
  octet.

| `0x60` - `0x6C`
| Timestamp.  Bit-packed encoding with different degrees of resolution based on the low-nibble (see *_TBD_* section
  for details).  The year in these encodings are offset (biased) from 1970 to provide a more compact encoding up to
  2097.  `0xF6` encodes variable length timestamp without year bias in a bit-packed encoding. `null.timestamp` is
  handled by `0xAE`.

| `0x6D` - `0x6F`
| _Illegal (reserved for future use)._

| `0x7_`
| Symbol with inline text and length specified by low nibble.  The encoding is similar to String.  `0x7E` and `0x7F` are
  length 14 and 15 inline symbols respectively. Variable length and symbols encoded with symbol IDs are handled via
  `0xF7`.  `null.symbol` is handled by `0xAE`.

| `0x8_`
| String, length specified by low nibble. `0x8E` and `0x8F` are length 14 and 15 strings respectively.
  Variable length strings are handled via `0xF8`.  `null.string` is handled by `0xAE`.

| `0x90`- `0x98`
| Int with length specified by the the low nibble.  `0x90` is zero. 

| `0x99`
| Boolean `false`.

| `0x9A`
| Boolean `true`.

| `0x9B`
| Float `0e0`

| `0x9C`
| _Illegal (reserved for 16-bit float)._

| `0x9D`
| 32-bit float.

| `0x9E`
| 64-bit float.

| `0x9F`
| _Illegal (reserved for future use)._

| `0xA0` - `0xA2`
| Symbol encoded with symbol ID and length specified by low nibble.  `0xA0` is `$0`.

| `0xA3`
| Symbol encoded with symbol ID and length specified by `VarUInt`.

| `0xA4`
| Single annotation encoded as a `VarUInt` symbol ID with a value following.

| `0xA5`
| Two annotations encoded as `VarUInt` symbol IDs with a value following.

| `0xA6`
| Variable length of annotations encoded as a `VarUInt`, followed by `VarUInt` encoded symbol IDs, followed by a value.
  (*_Note_*: we could add length prefixing here to make it consistent with Ion 1.0 annotations)

| `0xA7`
| Single annotation encoded as a `VarSym` with a value following.

| `0xA8`
| Two annotations encoded as `VarSym` with a value following.

| `0xA9`
| Variable length of annotations encoded as a `VarUInt`, followed by `VarSym` encoded symbol IDs, followed by a value.

| `0xAA`
| _Illegal (reserved for future use)._

| `0xAB`
| Single byte NOP pad.

| `0xAC`
| Variable length NOP pad.

| `0xAD`
| Delimited container end.

| `0xAE`
| Typed null.  The following byte is the Ion 1.0 type descriptor (without `0x3`) in the low nibble as the type of null.
  E.g., `0xAE 0x04` is `null.float`.  All other octets are illegal.

| `0xAF`
| `null.null`.

| `0xB_`
| Lists with length specified by the low nibble.  `0xBE` and `0xBF` are length 14 and 15 lists respectively.  Variable
  length lists are handled by `0xFB`. `null.list` is handled by `0xAE`.

| `0xC_`
| Sexp with length specified by the low nibble.  `0xCE` and `0xCF` are length 14 and 15 sexps respectively.  Variable
  length lists are handled by `0xFC`. `null.sexp` is handled by `0xAE`.

| `0xD_`
| Struct encoded with field names as symbol IDs and length specified by the low nibble. `0xDE` and `0xDF` are
  length 14 and 15 structs respectively.  Variable length structs with symbol ID encoded field use `0xF3`.
  `null.struct` is handled by `0xAE`.  `0xD1` is illegal as there are no structs with size one and Ion 1.1 eliminates
  the Ion 1.0 ordered struct encoding.

| `0xE0`
| Start of IVM.

| `0xE1`
| System e-expression with variable length ID.  A `VarUInt` follows encoding the rest of the bits of the macro ID.

| `0xE2` - `0xEF`
| Struct encoded with fields names as `VarSym` and length specified by the low nibble.  This is similar to `0xD_`
  encodings, except that the field names are encoded with the new format.  Variable length structs with `VarSym` encoded
  fields use `0xF2`. `null.struct` is handled by `0xAE`.

| `0xF0`
| Variable length prefixed E-expression.  A `VarUInt` specifies the entire length of the e-expression followed by a
  `VarUInt` identifier for the macro and the arguments of the e-expression following.

| `0xF1`
| _Illegal (reserved for future use)._

| `0xF2`
| Variable length structs with `VarSym` encoded field names.

| `0xF3`
| Variable length structs with `VarUInt` symbol ID encoded field names.

| `0xF4`
| Variable length int

| `0xF5`
| Variable length decimal

| `0xF6`
| Variable length timestamp.  Year format is not biased.

| `0xF7`
| Variable length symbol with content encoded as a `VarSym`

| `0xF8`
| Variable length string.

| `0xF9`
| Variable length BLOB (all BLOBs use this format)

| `0xFA`
| Variable length CLOB (all CLOBs use this format)

| `0xFB`
| Variable length list.

| `0xFC`
| Variable length sexp.

| `0xFD`
| Delimited list start.  The list ends with `0xAD`.

| `0xFE`
| Delimited s-expression start.  The s-expression ends with `0xAD`.

| `0xFF`
| Delimited struct start.  Note that all delimited structs have their field names encoded as `VarSym`. The struct ends
  with a special marker at the field name position of `0x00` `0xAD`.

|===

[appendix]
=== E-Expression Calling Conventions in Binary

IMPORTANT: *_WIP_*: This section is incomplete.

When an parameter to a template may have multiple values or invocations (i.e., _zero or one_, _one or more_, or _zero or
more_), a bit stream aligned to the nearest byte in big endian order precedes the encoded values/invocations to indicate
the presence or lack of presence of the argument at that position.  This bit stream is only used when one or more such
parameters with low-level encoding _or_ two or more parameters with typed opcode encoding exist.

For each parameter that is specified to have a _zero or more_ or _one or more_ cardinality, its argument prefixed with a
`VarInt` that specifies the length of the argument:

* When _positive_ this is an _octet length_ prefix for the values/invocations.

* When _negative_ this is a _count_ for
  the values/invocations. * When _zero_ *and* the encoding of the arguments use a full encoding opcode per argument the
  arguments are delimited by the `0xAD` (end indicator).

* When _zero_ *and* the encoding of the arguments use lower-level encodings, this denotes empty arguments.

This `VarInt` is not required when an e-expression encoding has the argument bit-stream indicating no argument is
present (i.e., empty).