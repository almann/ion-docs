[[sec:whatsnew]]
== What's New in Ion 1.1

We will go through a high-level overview of what is new and different in Ion 1.1 from Ion 1.0 from an implementer's
perspective.

=== Backwards Compatibility

Ion 1.1 is backwards compatible to Ion 1.0.  Backwards compatibility is defined as being able to _parse_ Ion 1.0 encoded
data *and* ensuring that any data model values produced by Ion 1.1 that are _not_ system values must be representable in
Ion 1.0.  To wit, any data that can be produced and read by an application in Ion 1.1 must have an equivalent
representation in Ion 1.0.

IMPORTANT: *_Discussion_*: Is this statement too weak? Specifically, should we be attempting to "fill in the holes" in
the Ion data model around system values?  Should we require that Ion 1.1 implementations _produce_ Ion 1.0 data?

Ion 1.1 is *not* required to preserve Ion 1.0 binary encoding in Ion 1.1 encoding contexts (i.e., the type codes and
lower-level encodings are not preserved in the new version).  The Ion Version Marker (IVM) is used to denote the
different versions of the syntax.  Ion 1.1 does retain text compatibility with Ion 1.0 in that the changes are a strict
superset of the grammar, however due to the updated system symbol table, symbol IDs referred to using the `$n` syntax
for symbols beyond the 1.0 system symbol table will not be compatible.

[[sec:whatsnew-text]]
=== Text Syntax Changes

Ion 1.1 text *must* use the `$ion_1_1` version marker at the top-level of the data stream or document.

As described earlier, Ion 1.1 textually compatible with all existing Ion 1.0 text.  The only syntax change is the
*encoding expression* (*e-expression*) syntax which allows for the invocation of macros in the data stream. This syntax
is grammatically similar to s-expressions, except that these expressions are opened with `(:` and closed with `)`.  For
example, `(:a 1 2)` would expand the macro named `a` with the arguments `1` and `2`. See the <<sec:whatsnew-eexp,
Macros, Templates, and Encoding-Expressions>> section for details.

This syntax is allowed anywhere an Ion value is allowed:

.Figure {counter:figure-number}. E-expression Examples
[source,plain,%unbreakable]
----
(:foo 1 2)
[1, 2, (:bar 3 4)]
(cons a (:baz b))
{c: (:bop d)}
----

E-expressions are also grammatically allowed in the field name position of a struct and when used there, indicate that
the expression should expand to a struct value that is spliced into:

.Figure {counter:figure-number}. E-Expression in field position of struct.
[source,plain,%unbreakable]
----
{
    a:1,
    b:2,
    (:foo 1 2),
    c: 3,
}
----

In the above example, the e-expression `(:foo 1 2)` must evaluate into a struct that will be spliced between the `b`
field and the `c` field.  If it does not evaluate to a struct, then the above is an error.

[[sec:whatsnew-bin]]
=== Binary Encoding Changes

Ion 1.1 binary encoding reorganizes the type descriptors to better support macros and make certain encodings more
compact, and certain lower priority encodings marginally less compact.  The IVM for this encoding is the octet sequence
`0xE0 0x01 0x01 0xEA`.

[[sec:whatsnew-inline-symbols]]
==== Inlined Symbolic Tokens

IMPORTANT: *_Discussion_*: Should we call this something else (e.g., _non-interned_)?

In Ion 1.0, symbol values, field names, and annotations are required to be encoded using a symbol ID and a local symbol
table.  For some use cases (e.g., as write once, read maybe logs) this creates a burden on the writer and may not
actually be efficient for reading.  Ion 1.1 introduces optional binary syntax for encoding inline UTF-8 sequences for
these tokens which can allow an encoder to have flexibility in whether or not to add a given symbolic token to the
symbol table.

Ion text requires no change for this feature as it already had inline symbolic tokens without using the local symbol
table.  Ion text also has compatible syntax for representing the local symbol table and encoding of symbolic tokens with
their position in the table (i.e., the `$id` syntax).

[[sec:whatsnew-delimited]]
==== Delimited Containers

In Ion 1.0, all data is length prefixed.  While this is good for optimizing the reading of data, it requires an Ion
encoder to buffer any data in memory to calculate the data's length.  Ion 1.1 introduces optional binary syntax to allow
containers to be encoded with an end marker.

==== Low-level Encoding Changes

The `VarUInt` and `VarInt` encodings have been changed to put their continuation bits before the content.  This is
similar in structure to UTF-8 encoding.  `VarInt` has also been changed to be a two's complement representation rather
than a signed magnitude representation.  Benchmarks have shown that these encoding changes to be about 15% faster than
the Ion 1.0 version of the encoding.

The `Int` encoding has also been changed to be two's complement over its original signed magnitude representation.

A new primitive encoding type, called `VarSym` has been introduced to flexibly encode symbol IDs and symbolic tokens
with inline text.  This encoding is structurally identical to `VarInt` but is used to encode symbolic tokens that could
be either a symbol ID or a length of inline UTF-8 octets.  Positive integers represent symbol IDs, Negative integers
represent a length of UTF-8 octets to follow.  Zero is treated specially.  Specifically, A `VarSym` encoded as `0x00`
indicates that a special control opcode follows.  The following table specifies the opcodes, all other opcodes are
illegal.

[%header,%unbreakable,cols="1,1"]
|===

| Control Opcode
| Description

| `0x1_` - `0x4_`, `0xF0`
| E-expression follows.  This is only valid when a field name in a struct is expected.

| `0x70`
| Represents `$0`.

| `0x80`
| Represents empty inline text (i.e., `''`).

|===

The padded representations of zero in `VarSym` (e.g., `0x80 0x00`, `0xC0 0x00 0x00`) mean `$0`.

==== Type Encoding Changes

All Ion binary encodings use the new low-level encodings as specified in the previous section.  Many of the opcodes used
in Ion 1.0 have been re-organized to make e-expressions compact.

Typed `null` values are now all encoded with two bytes with the `0xAE` opcode.  Lists and s-expressions have two
encodings, the Ion 1.0 length prefixed encoding and the new delimited form that end with the `0xAD` end opcode.  Struct
values have three encodings, the Ion 1.0 length prefixed encoding, the length prefixed encoding using `VarSym` to encode
field names (allowing for inline symbol text), and the delimited form that encodes its field names with `VarSym` (there
is no delimited form with Ion 1.0 encoding of field names).  Symbol values have two encodings, one is the Ion 1.0
encoding with the symbol ID, and the other one is structurally identical to the encoding of strings, which are used for
symbols with inline text.

Annotated values no longer have an outer length container.  They are now encoded with an opcode that specifies a single
annotation with value following; an opcode that specifies two annotations with a value following; and finally, an opcode
that specifies a variable length of annotations followed by a value.  The latter encoding is similar to how Ion 1.0
annotations are encoded with the exception that there is no outer length.

Integers now use an `Int` sub-field instead of the Ion 1.0 encoding using sign magnitude (with two opcodes).

Decimals are structurally identical to their Ion 1.0 counterpart with the exception of the negative zero coefficient.
The Ion 1.1 `VarInt` encoding is two's complement, so negative zero cannot be encoded directly with it.  Instead an
encoding opcode is allocated specifically for encoding negative zero decimals.

Timestamps no longer encode their components as octet-aligned fields.  The Ion 1.1 format uses a packed bit encoding and
has a biased form (encoding the year field as an offset from 1970) to make common encodings of timestamp easily fit in a
64-bit word for microsecond and nanosecond precision (with unknown UTC offset).  Benchmarks have shown this new encoding
to be 59% faster to encode and 21% faster to decode.  A non-biased, arbitrary length timestamp with packed bit encoding
is defined for cases outside of the common cases.

==== Encoding Expressions in Binary

E-expressions, in text, are denoted with `(:` ... `)`.  In binary this is encoded as a _macro identifier_ followed by
the encoding of the arguments to the invocation.  The macro's definition statically determines how the
arguments are to be laid out.  When all arguments for a macro are of fixed length the parameters are layed out
with their respective encodings. An argument may be a full Ion value with encoding opcode, or it could be a lower-level
encoding (e.g., fixed width integer or `VarInt`/`VarUInt`).

Parameters to a macro have a cardinality specified _per_ parameter.  The binary encoding uses a variable length
bit-stream (encoded as a `VarUInt`) before the encoding of the arguments to indicate 

When an parameter to a template may have multiple values or invocations (i.e., _optional_, _one or more_, or _zero or
more_), a bit stream aligned to the nearest byte in big endian order precedes the encoded values/invocations to indicate
the presence or lack of presence of the argument at that position.  This bit stream is only used when one or more such
parameters with low-level encoding _or_ two or more parameters with opcode encoding exist.

* When _positive_ this is an _octet length_ prefix for the values/invocations. * When _negative_ this is a _count_ for
  the values/invocations. * When _zero_ *and* the encoding of the arguments use a full encoding opcode per argument the
  arguments are delimited by the `0xAD` (end indicator).

* When _zero_ *and* the encoding of the arguments use lower-level encodings, this denotes empty arguments.


[[sec:whatsnew-eexp]]
=== Macros, Templates, and Encoding-Expressions

Ion 1.1 introduces a new kind of encoding called *encoding expression* (*e-expression*).  These expressions are (in text
syntax) similar to s-expressions, but they are not part of the data model and are _evaluated_ into one or more Ion
values (called a _stream_) which enable compact representation of Ion data.  E-expressions represent the invocation of
either system defined or user defined *macros* with arguments that are either themselves e-expressions, value literals,
or container constructors (list, sexp, struct syntax containing e-expressions) corresponding to the formal parameters of
the macro's definition.  The resulting stream is then expanded into the resulting Ion data model. At the top level, the
stream becomes individual top-level values.  Consider for illustrative purposes an e-expression `(:values 1 2 3)` that
evaluates to the stream `1`, `2`, `3` and `(:void)` that evaluates to the empty stream.  In the following examples,
`values` and `void` are the names of the macros being invoked and each line is equivalent.

.Figure {counter:figure-number}. Top-level E-expressions
[source,plain,%unbreakable]
----
a (:values 1 2 3) b (:void) c
a 1 2 3 b c
----

Within a list or s-expression, the stream becomes additional child elements in the collection.

.Figure {counter:figure-number}. E-expressions in lists
[source,plain,%unbreakable]
----
[a, (:values 1 2 3), b, (:void), c]
[a, 1, 2, 3, b, c]
----

.Figure {counter:figure-number}. E-expressions in s-expressions
[source,plain,%unbreakable]
----
(a (:values 1 2 3) b (:void) c)
(a 1 2 3 b c)
----

Within a struct at the field name position, the resulting stream must contain structs and each of the fields in those
structs become fields in the enclosing struct (the value portion is not specified); at the value position, the resulting
stream of values becomes fields with whatever field name corresponded before the e-expression.  In the following
examples, let us define `(:struct c 5)` that evaluates to a single struct `{c: 5}`.

.Figure {counter:figure-number}. E-expressions in structs
[source,plain,%unbreakable]
----
{a: (:values 1 2 3), b: 4, (:struct c 5), d: 6}
{a: 1, a: 2, a: 3, b: 4, c: 5, d: 6}
----

==== Encoding Context and Modules

In Ion 1.0, there is a single _encoding context_, the local symbol table.  In Ion 1.1, the _encoding context_ becomes
the following:

* The local symbol table which is a list of strings.  This is used to encode/decode symbolic tokens.

* The local macro table which is a list of macros.  This is used to reference macros that can be invoked by
e-expressions.

* A mapping of a string name to *module* which is an organizational unit of symbol definitions and macro definitions.
  Within the encoding context, this name is unique and used to address a module's contents either as the list of symbols
  to install into the local symbol table, the list of macros to install into the local macro table, or to qualify the
  name of a macro in a text e-expression or the definition of a macro.

The *module* is a new concept in Ion 1.1.  It contains:

* A list of of strings representing the symbol table of the module.

* A list of macro definitions.

Modules can be imported from the catalog (they subsume shared symbol tables), but can also be defined locally.  Modules
are referenced as a group to allocate entries in the local symbol table and local macro table.

Ion 1.1 introduces a new system value for the encoding context (see the *_TBD_* section for details.)

==== Macro Definitions

Macros can be defined by a user either directly in a module in an encoding context, or in a shared module defined
externally (i.e., shared symbol table).  A macro has a name which must be unique in a module *or* it may have no name.

Ion 1.1 defines a list of _system macros_ that are built-in in the module named `$ion`.  Unlike the system symbol table,
which is always installed and accessible in the local symbol table, the system macros are both always accessible to
e-expressions and not installed in the local macro table by default.

In Ion binary, macros are always addressed in e-expressions by the offset in the local macro table.  System macros may
be addressed by the system macro identifier using a specific encoding op-code.  In Ion text, macros may be addressed by
the offset in the local macro table (mirroring binary), its name if its name is unique within the local macro table, or
by qualifying the macro name/offset with the module name in the encoding context.  An e-expression can _only_ refer to
macros installed in the local macro table.

For illustrative purposes let's consider the module named `foo` that has a macro named `bar` at offset 5 installed at
the begining of the local macro table.

.Figure {counter:figure-number}. E-expressions name resolution in text
[source,plain,%unbreakable]
----
// allowed if there are no ther macros named 'bar' 
(:bar)
// fully qualified by module--always allowed
(:foo:bar)
// by local macro table offset
(:5)
// system macros are always addressable by name--in binary this would be a different offset with a different opcode
(:$ion:void)
----

==== Template Definition Language

User defined macros are defined by their *template* which defines how they are invoked and what stream of data they
evaluate to.  This template is defined using a domain specific language with s-expressions.  A template defines a fixed
set of zero or more parameters that it can accept.  These parameters each have their own cardinality which can be
specified as _required_ (exactly one), _optional_ (zero or one), _zero or more_, and _one or more_.  Furthermore the
template defines what type of argument can be accepted by each of these parameters:

* Specific type(s) of Ion value.

* Lower-level binary data (e.g. fixed width integers or `VarUInt`) for efficient encodings of the e-expressions in
binary.

* Specific e-expressions to allow for structural composition of macros and efficient encoding in binary.

The template defintion includes a *template expression* that make up the body of the template (see the *_TBD_* section
for details).  In the language, system macros, macros defined in previously defined modules in the encoding context, and
macros defined previously in the current module are accessible to be invoked with `(name ...)` syntax where `name` is
the macro to be invoked.  Certain names in the previous syntax are reserved for special forms (i.e., `quote`, `if`,
`when`, `unless`, and `each`).  When a macro name is shadowed by a special form, or is ambiguous with respect to all
macros visible, it can always be qualified with `(module:name ...)` syntax.

INFORMATION: *_TBD_* put an easy to access example of a template definition.

==== Shared Modules

Ion 1.1 extends the concept of _shared symbol table_ to be a _shared module_.  An Ion 1.0 shared symbol table is a
shared module with no macro definitions.  A new schema for the convention of serializing shared modules in Ion are
introduced in Ion 1.1 (see the *_TBD_* section for details).

=== System Symbol Table Changes

The system symbol table in Ion 1.1 adds the following symbols:

[%header,%unbreakable,cols="1,1"]
|===

| ID
| Symbol Text

| 10
| `$ion_encoding`

| 11
| `$ion_literal`

|===

System macro identifiers are namespaced separately and therefore do not have entries in the system symbol table.

IMPORTANT: These assignments are provisional.  Specifically assignments for the template definition language have not
been established.

<<<

[appendix]
=== Binary Encoding Opcodes

The following is a table of the encoding opcodes for the data format (the leading byte that indicates how the following
bytes should be decoded).

[%header,%unbreakable,cols="1,1"]
|===

| Encoding Opcode
| Description

| `0x0_`
.4+|
  E-expression with macro identifier encoded in the opcode.  The high-order two bits indicate that the lower six bits
  represent the macro identifier to expand (64 single opcode expansions).  Arguments follow.

| `0x1_`

| `0x2_`

| `0x3_`

| `0x4_`
| E-expression with variable length macro identifier.  The low nibble is the top four bits of the macro identifier.
  A `VarUInt` follows encoding the rest of the bits of the macro identifier.  Arguments follow.

| `0x50` - `0x5E`
| Decimal. Length specified by low nibble.  Encoding is structurally as in Ion 1.0, but with the new `VarInt` and `Int`
  encodings for the coefficient and exponent sub-fields.  Also note that `0x5E` is a length 14 decimal and not variable
  length.  `0xF5` encodes variable length decimals. `null.decimal` is handled by `0xAE`.

| `0x5F`
| Decimal, with negative zero coefficient.  Length is specified by `VarUInt` and an exponent encoded as an `Int`
  follows.  The new encodings for `VarInt`/`Int` are not sign magnitude, so this special case is handled with the type
  octet.

| `0x60` - `0x6C`
| Timestamp.  Bit-packed encoding with different degrees of resolution based on the low-nibble (see timestamp encoding
  for details).  The year in these encodings are offset (biased) from 1970 to provide a more compact encoding up to
  2097.  `0xF6` encodes variable length timestamp without year bias in a bit-packed encoding. `null.timestamp` is
  handled by `0xAE`.

| `0x6D` - `0x6F`
| Illegal (reserved for future use).

| `0x7_`
| Symbol with inline text and length specified by low nibble.  The encoding is equivalent to String.  Variable
  length and symbols encoded with symbol IDs are handled via `0xF7`, so `0x7E` and `0x7F` are length 14 and 15 inline
  symbols respectively. `null.symbol` is handled by `0xAE`.

| `0x8_`
| String, length specified by low nibble. `0x8E` and `0x8F` are length 14 and 15 strings respectively.
  Variable length strings are handled via `0xF8`.  `null.string` is handled by `0xAE`.

| `0x90`- `0x98`
| Int with length specified by the the low nibble.  `0x90` is zero. 

| `0x99`
| Boolean `false`.

| `0x9A`
| Boolean `true`.

| `0x9B`
| Float `0e0`

| `0x9C`
| Illegal (reserved for 16-bit float).

| `0x9D`
| 32-bit float.

| `0x9E`
| 64-bit float.

| `0x9F`
| Illegal (reserved for future use).

| `0xA0` - `0xA2`
| Symbol encoded with symbol ID and length specified by low nibble.  `0xA0` is `$0`.

| `0xA3`
| Symbol encoded with symbol ID and length specified by `VarUInt`.

| `0xA4`
| Single annotation encoded as a `VarUInt` symbol ID with a value following.

| `0xA5`
| Two annotations encoded as `VarUInt` symbol IDs with a value following.

| `0xA6`
| Variable length of annotations encoded as a `VarUInt`, followed by `VarUInt` encoded symbol IDs, followed by a value.

| `0xA7`
| Single annotation encoded as a `VarSym` with a value following.

| `0xA8`
| Two annotations encoded as `VarSym` with a value following.

| `0xA9`
| Variable length of annotations encoded as a `VarUInt`, followed by `VarUInt` encoded symbol IDs, followed by a value.

| `0xAA`
| Illegal (reserved for future use).

| `0xAB`
| Single byte NOP pad.

| `0xAC`
| Variable length NOP pad.

| `0xAD`
| Delimited container end.

| `0xAE`
| Typed null.  The following byte is the Ion 1.0 type descriptor (without `0x3`) in the low nibble as the type of null.
  E.g., `0xAE 0x04` is `null.float`.  All other octets are illegal.

| `0xAF`
| `null.null`.

| `0xB_`
| Lists with length specified by the low nibble.  `0xBE` and `0xBF` are length 14 and 15 lists respectively.  Variable
  length lists are handled by `0xFB`. `null.list` is handled by `0xAE`.

| `0xC_`
| Sexp with length specified by the low nibble.  `0xCE` and `0xCF` are length 14 and 15 sexps respectively.  Variable
  length lists are handled by `0xFC`. `null.sexp` is handled by `0xAE`.

| `0xD_`
| Struct encoded with field names as symbol IDs and length specified by the low nibble. `0xDE` and `0xDF` are
  length 14 and 15 structs respectively.  Variable length structs with symbol ID encoded field use `0xF3`.
  `null.struct` is handled by `0xAE`.  `0xD1` is illegal as there are no structs with size one and Ion 1.1 eliminates
  the Ion 1.0 ordered struct encoding.

| `0xE0`
| Start of IVM.

| `0xE1`
| System e-expression with variable length ID.  The low nibble is the top four bits of the macro ID.
  A `VarUInt` follows encoding the rest of the bits of the macro ID.

| `0xE2` - `0xEF`
| Struct encoded with fields names as `VarSym` and length specified by the low nibble.  This is similar to `0xD_`
  encodings, except that the field names are encoded with the new format.  Variable length structs with `VarSym` encoded
  fields use `0xF2`. `null.struct` is handled by `0xAE`.

| `0xF0`
| Variable length prefixed E-expression.  A `VarUInt` specifies the entire length of the e-expression followed by a
  `VarUInt` identifier for the macro and the arguments of the e-expression following.

| `0xF1`
| Illegal (reserved for future use).

| `0xF2`
| Variable length structs with `VarSym` encoded field names.

| `0xF3`
| Variable length structs with `VarUInt` symbol ID encoded field names.

| `0xF4`
| Variable length int

| `0xF5`
| Variable length decimal

| `0xF6`
| Variable length timestamp.  Year format is not biased.

| `0xF7`
| Variable length symbol with content encoded as a `VarSym`

| `0xF8`
| Variable length string.

| `0xF9`
| Variable length BLOB (all BLOBs use this format)

| `0xFA`
| Variable length CLOB (all CLOBs use this format)

| `0xFB`
| Variable length list.

| `0xFC`
| Variable length sexp.

| `0xFD`
| Delimited list start.

| `0xFE`
| Delimited sexp start.

| `0xFF`
| Delimited struct start.  Note that all delimited structs have their field names encoded as `VarSym`.

|===