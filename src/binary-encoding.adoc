= Binary Encoding
:toc:

[[encoding_primitives]]
== Encoding primitives

[[varuint]]
=== `VarUInt`

A variable-length unsigned integer.

The bytes of a ``VarUInt``s are written in
link:https://en.wikipedia.org/wiki/Endianness:[Little Endian byte order]. This means that the first byte will contain
the ``VarUInt``'s least significant bits.

The least significant bits in the `VarUInt` indicate the number of bytes that were used to encode the integer. The number
of bytes can be found by counting the number of trailing zeros in the first byte(s) and adding one to it. All bits that
are more significant than the first `1` represent the magnitude of the `VarUInt`.

==== Example encoding of VarUInt 14 ====
[source]
----
              ┌──── Lowest bit is 1 (`end`), indicating
              │     this is the only byte.
0 0 0 1 1 1 0 1
└─────┬─────┘
unsigned int 14
----

==== Example encoding of VarUInt 729 ====
[source]
----
             ┌──── There's 1 trailing zero, so this
             │     integer is two bytes wide.
            ┌┴┐
0 1 1 0 0 1 1 0  0 0 0 0 1 0 1 1
└────┬────┘      └──────┬──────┘
lowest 6 bits    highest 8 bits
of the unsigned  of the unsigned
integer          integer
----

==== Example encoding of VarUInt 21,043 ====
[source]
----
            ┌───── There are 2 trailing zeros, so this
            │      integer is three bytes wide.
          ┌─┴─┐
1 0 0 1 1 1 0 0  1 0 0 1 0 0 0 1  0 0 0 0 0 0 1 0
└───┬───┘        └──────┬──────┘  └──────┬──────┘
lowest 6 bits    next 8 bits of   highest 8 bits
of the unsigned  the unsigned     of the unsigned
integer          integer          integer
----

NOTE: Ion 1.0 uses link:https://en.wikipedia.org/wiki/Endianness[Big Endian byte order] and indicates the width of the
integer by having
link:https://amazon-ion.github.io/ion-docs/docs/binary.html#varuint-and-varint-fields[an `end` flag bit in the highest
 bit of each byte].

[[varint]]
=== `VarInt`

A variable-length signed integer.

From an encoding perspective, ``VarInt``s are structurally similar to a `VarUInt` (<<varuint, described above>>). Both
encode their bytes using Little Endian byte order, and both use the count of trailing zero bits to indicate how many
bytes were used to encode the integer. They differ in the _interpretation_ of their bits; while a ``VarUInt``'s bits
are unsigned, a ``VarInt``'s bits are encoded using
link:https://en.wikipedia.org/wiki/Two%27s_complement[two's complement notation].

TIP: An implementation could choose to read a `VarInt` by instead reading a `VarUInt` and then reinterpreting its bits
as two's complement.

==== Example encoding of VarInt 14 ====
[source]
----
              ┌──── Lowest bit is 1 (`end`), indicating
              │     this is the only byte.
0 0 0 0 1 1 1 1
└─────┬─────┘
 2's comp. 14
----

==== Example encoding of VarInt -14 ====
[source]
----
              ┌──── Lowest bit is 1 (`end`), indicating
              │     this is the only byte.
1 1 1 0 0 1 0 1
└─────┬─────┘
 2's comp. -14
----

==== Example encoding of VarInt 729 ====
[source]
----
             ┌──── There's 1 trailing zero, so this
             │     integer is two bytes wide.
            ┌┴┐
0 1 1 0 0 1 1 0  0 0 0 0 1 0 1 1
└────┬────┘      └──────┬──────┘
lowest 6 bits    highest 8 bits
of the 2's       of the 2's
comp. integer    comp. integer
----

==== Example encoding of VarInt -729 ====
[source]
----
             ┌──── There's 1 trailing zero, so this
             │     integer is two bytes wide.
            ┌┴┐
1 0 0 1 1 1 1 0  1 1 1 1 0 1 0 0
└────┬────┘      └──────┬──────┘
lowest 6 bits    highest 8 bits
of the 2's       of the 2's
comp. integer    comp. integer
----

[[fixeduint]]
=== `FixedUInt`

A fixed-width, little-endian, unsigned integer whose length is inferred from the context in which it appears.

==== Example encoding of FixedUInt 3,954,261 ====
[source]
----

0 1 0 1 0 1 0 1  0 1 0 1 0 1 1 0  0 0 1 1 1 1 0 0
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
lowest 8 bits    next 8 bits of   highest 8 bits
of the unsigned  the unsigned     of the unsigned
integer          integer          integer
----

[[fixedint]]
=== `FixedInt`

A fixed-width, little-endian, signed integer whose length is known from the context in which it appears. Its bytes
are interpreted as two's complement.

==== Example encoding of FixedInt -3,954,261 ====
[source]
----

1 0 1 0 1 0 1 1  1 0 1 0 1 0 0 1  1 1 0 0 0 0 1 1
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
lowest 8 bits    next 8 bits of   highest 8 bits
of the 2's       the 2's comp.    of the 2's comp.
comp. integer    integer          integer
----

[[varsym]]
=== `VarSym`

A variable-length symbol whose UTF-8 bytes can be inline, found in the symbol table, or derived from a macro
expansion.

A `VarSym` begins with a <<varint,`VarInt`>>; once this integer has been read, we can evaluate it to determine how to proceed. If the VarInt is:

* *greater than zero*, it represents a symbol ID. The symbol’s associated text can be found in the local symbol table.
No more bytes follow.
* *less than zero*, its absolute value represents a number of UTF-8 bytes that follow the `VarInt`. These bytes
represent the symbol’s text.
* *exactly zero*, another byte follows that is an <<opcodes, opcode>>. The `VarSym` parser is not responsible for
evaluating this opcode, only returning it—the caller will decide whether the opcode is legal in the current context.
Example usages of the opcode include:
** Representing SID `$0` as `0x70`
** Representing the empty string (`""`) as `0x80`
** When used to encode a struct field name, the opcode can invoke a macro that will evaluate to a struct whose key/value
pairs are spliced into the parent struct (TODO: Link)
** In a delimited struct, terminating the sequence of (name, value) pairs with `0xAD`. (TODO: Link)

==== Example encoding of a `VarSym` with symbol ID `$10` ====
[source]
----
              ┌─── The leading VarInt ends in a `1`,
              │    no more VarInt bytes follow.
              │
0 0 0 1 0 1 0 1
└─────┬─────┘
  2's comp.
  positive 10
----

==== Example encoding of a `VarSym` with symbol text `hello` ====
[source]
----
              ┌─── The leading VarInt ends in a `1`,
              │    no more VarInt bytes follow.
              │      h         e        l        l        o
1 1 1 1 0 1 1 1  01101000  01100101 01101100 01101100 01101111
└─────┬─────┘    └─────────────────────┬─────────────────────┘
  2's comp.               5-byte UTF-8 encoded "hello"
  negative 5
----

==== Example encoding of `''` (symbol with empty text) using an opcode ====
[source]
----
              ┌─── The leading VarInt ends in a `1`,
              │    no more VarInt bytes follow.
              │
0 0 0 0 0 0 0 1  1110000
└─────┬─────┘    └──┬──┘
  2's comp.      opcode 0x70:
  zero           empty symbol
----

[[opcodes]]
== Opcodes

An _opcode_ is a 1-byte <<fixeduint, `FixedUInt`>> that tells the reader what the next expression represents and how the
bytes that follow should be interpreted.

=== Overview table

The meanings of each opcode are organized loosely by their high and low nibbles.

[cols="^.^1a,^.^1a,3a"]
|===
|High nibble | Low nibble | Meaning

|`0x0_` to `0x3_`
| `*`
|Single-byte macro invocations

|`0x4_`
| `*`
|Multibyte macro invocations

.4+|`0x5_`
| `0`-`8`
|Integers

|`9`
<|Reserved

|`A`-`D`
<|Floats

|`E`-`F`
<|Booleans

|`0x6_`
|`*`
|Decimals

|`0x7_`
|`*`
|Timestamps

|`0x8_`
|`*`
|Strings

|`0x9_`
|`*`
|Symbols with inline text

|`0xA_`
|`*`
|Lists

|`0xB_`
|`*`
|S-expressions

.3+|`0xC_`
|`0`
|Empty struct

|`1`
<|Reserved

|`2`-`F`
<|Structs with symbol address field names

.2+|`0xD_`
|`0`-`1`
|Reserved

|`2`-`F`
<|Structs with `VarSym` field names

.9+|`0xE_`
|`0`
|Ion version marker

|`1`-`3`
<|Symbols with symbol table text

|`4`-`6`
<|Annotations with symbol table text

|`7`-`9`
<|Annotations with `VarSym` text

|`A`
<|`null.null`

|`B`
<|Typed nulls

|`C`-`D`
<|NOP

|`E`
<|Reserved

|`F`
<|System macro invocation

.16+|`0xF_`
|`0`
|Delimited container end

|`1`
<|Delimited list start

|`2`
<|Delimited S-expression start

|`3`
<|Delimited struct with `VarSym` field names start

|`4`
<|Variable length prefixed macro invocation

|`5`
<|Variable length integer

|`6`
<|Variable length decimal

|`7`
<|Variable length, long-form timestamp

|`8`
<|Variable length string

|`9`
<|Variable length symbol encoded as `VarSym`

|`A`
<|Variable length list

|`B`
<|Variable length S-expression

|`C`
<|Variable length struct with symbol address field names

|`D`
<|Variable length struct with `VarSym` field names

|`E`
<|Variable length blob

|`F`
<|Variable length clob

|===



[[single_byte_macro_invocations]]
=== Single-byte macro invocations

// TODO: link to macros chapter

If the value of the opcode is less than `64` (`0x40`), it represents an invocation of the macro at the corresponding
__address__—an offset within the local macro table.

==== Example encoding of a single-byte invocation of the macro at address `7`
[source]
----
0 0 0 0 0 1 1 1
└──────┬──────┘
  FixedUInt 7
----

==== Example encoding of an invocation of the macro at address `31`
[source]
----
0 0 0 1 1 1 1 1
└──────┬──────┘
  FixedUInt 31
----

// TODO: Link to macro calling conventions

Note that the opcode alone tells us which macro is being invoked, but it does not supply enough information for the
reader to parse any arguments that may follow. The parsing of arguments is described in detail in the section _Macro
calling conventions_.

[[multi_byte_macro_invocations]]
=== Multibyte macro invocations

While invocations of macro addresses in the range `[0, 63]` can be encoded in a single byte using
<<single_byte_macro_invocations, single byte macro invocations>>, many applications will benefit from defining more than
64 macros.

If the high nibble of the opcode is `0x4_`, then the low nibble represents the four least significant bits of the macro
address. A <<varuint, `VarUInt`>> follows that contains the remaining, more significant bits.

Because the first 64 macro addresses can already be encoded using high nibbles `0` to `3`, the decoded value is biased
by 64. (That is: the reader must add 64 to the decoded value. If the decoded value is `0`, the macro address that it
represents is `64`.)

Because the address is encoded using a `VarUInt`, there is no (theoretical) limit to the number of addresses that can
be invoked. However, larger addresses require more bytes to encode. This following table shows the number of bytes
needed to encode invocations of macro addresses in various ranges.

|===
| Address range | Bytes needed | Magnitude bits available

|0 to 63
|1
|6

|64 to 2,112
|2
|11

|2,113 to 262,208
|3
|18

|262,209 to 33,554,432
|4
|25
|===

==== Example encoding of an invocation of the macro at address `131`
[source]
----
                               ┌─── The address VarUInt ends in a `1`,
                               │    no more VarUInt bytes follow.
                               │
0 1 0 0 0 0 1 1  0 0 0 0 1 0 0 1
└──┬──┘ └──┬──┘  └──────┬──────┘
   │       │            └──────────── VarUInt containing the 7 most
   │       └── 4 least significant    significant bits of the macro
opcode high    bits of the macro      address
nibble 4       address

Magnitude bits: 0000100_0011
Decoded value : 67
Biased value  : 131
----

==== Example encoding of an invocation of the macro at address `1211`
[source]
----

                               ┌─── The address VarUInt ends in a `1`,
                               │    no more VarUInt bytes follow.
                               │
0 1 0 0 1 0 1 1  1 0 0 0 1 1 1 1
└──┬──┘ └──┬──┘  └──────┬──────┘
   │       │            └──────────── VarUInt containing the 7 most
   │       └── 4 least significant    significant bits of the macro
opcode high    bits of the macro      address
nibble 4       address

Magnitude bits: 1000111_1011
Decoded value : 1,147
Biased value  : 1,211
----

==== Example encoding of an invocation of the macro at address `71376`
[source]
----

                              ┌─── The address VarUInt ends in `10`; the trailing
                              │    zero indicates that one more VarUInt byte follows.
                             ┌┴┐
0 1 0 0 0 0 0 0  1 0 1 0 0 1 1 0  0 1 0 0 0 1 0 1
└──┬──┘ └──┬──┘  └──────┬──────┘  └──────┬──────┘
   │       │            │                └──────────── the 8 most significant bits
   │       │            │                              of the macro address
   │       │            │
   │       │            └──────────── VarUInt containing the next 7 most
   │       └── 4 least significant    significant bits of the macro
opcode high    bits of the macro      address
nibble 4       address

Magnitude bits: 01000101_101001_0000
Decoded value : 71,312
Biased value  : 71,376
----

NOTE: From this point on in the document, example encodings are given in hexidecimal notation.

[[booleans]]
== Booleans

`0x5E` represents boolean `true`, while `0x5F` represents boolean `false`.

// XXX: Structurally, these examples should be at depth 3. However, all other example sections in the doc
//      are at heading depth 4, which keeps them out of the TOC. These are also at depth 4 for consistency.

==== Example encoding of `true`
[source]
----
5e
----

==== Example encoding of `false`
[source]
----
5f
----

[[numbers]]
== Numbers

[[integers]]
=== Integers

Opcodes in the range `0x50` to `0x58` represent an integer. The opcode is followed by a <<fixedint, `FixedInt`>> that
represents the integer value. The low nibble of the opcode (`0x_0` to `0x_8`) indicates the size of the `FixedInt`.
Opcode `0x50` represents integer `0`; no more bytes follow.

Integers that require more than 8 bytes are encoded using the variable-length integer opcode `0xF5`,
followed by a
<<varuint, VarUInt>> indicating how many bytes of representation data follow.

==== Example encoding of `0`
[source]
----
┌──── Opcode in 50-58 range indicates integer
│┌─── Low nibble 0 indicates
││    no more bytes follow.
50
----

==== Example encoding of `17`
[source]
----
┌──── Opcode in 50-58 range indicates integer
│┌─── Low nibble 1 indicates
││    a single byte follows.
51 11
    └── FixedInt 17
----

==== Example encoding of `-944`
[source]
----
┌──── Opcode in 50-58 range indicates integer
│┌─── Low nibble 2 indicates
││    that two bytes follow.
52 50 fc
   └─┬─┘
FixedInt -944
----

==== Example variable-length encoding of `-944`
[source]
----
┌──── Opcode F5 indicates a variable-length integer, VarUInt length follows
│   ┌─── VarUInt 2; a 2-byte FixedInt follows
│   │    that two bytes follow.
F5 05 50 fc
      └─┬─┘
   FixedInt -944
----

[[floats]]
=== Floats

Float values are encoded using the IEEE-754 specification, and can be serialized in four sizes:

* 0 bits (0 bytes), representing the value 0e0 and indicated by opcode `0x5A`
* 16 bits (2 bytes, link:https://en.wikipedia.org/wiki/Half-precision_floating-point_format[half precision]),
indicated by opcode `0x5B`
* 32 bits (4 bytes, link:https://en.wikipedia.org/wiki/Single-precision_floating-point_format[single precision]),
indicated by opcode `0x5C`
* 64 bits (8 bytes, link:https://en.wikipedia.org/wiki/Double-precision_floating-point_format[double precision]),
indicated by opcode `0x5D`

Note that in the Ion data model, float values are always 64 bits. However, if a value can be losslessly serialized
in fewer than 64 bits, applications may choose to do so.

==== Example encoding of `0e0`
[source]
----
┌──── Opcode in range 5A-5D indicates a float
│┌─── Low nibble A indicates
││    a 0-length float; 0e0
5A
----

==== Example encoding of `3.14`
[source]
----
┌──── Opcode in range 5A-5D indicates a float
│┌─── Low nibble B indicates a 2-byte float
││
5B 42 47
   └─┬─┘
half-precision 3.14
----

==== Example encoding of `3.1415927`
[source]
----
┌──── Opcode in range 5A-5D indicates a float
│┌─── Low nibble C indicates a 4-byte,
││    single-precision value.
5C 40 49 0F DB
   └────┬────┘
single-precision 3.1415927
----

==== Example encoding of `3.141592653589793`
[source]
----
┌──── Opcode in range 5A-5D indicates a float
│┌─── Low nibble C indicates a 4-byte,
││    single-precision value.
5D 40 09 21 FB 54 44 2D 18
   └──────────┬──────────┘
double-precision 3.141592653589793
----

[[decimals]]
=== Decimals

If an opcode has a high nibble of `0x6_`, it represents a decimal. Low nibble values `0x_E` and below indicate
the number of trailing bytes used to encode the decimal.

The body of the decimal is encoded as a <<varint, `VarInt`>> representing its exponent, followed by a `FixedInt`
representing its coefficient. The width of the coefficient is the total length of the decimal encoding minus the length
of the exponent. It is possible for the coefficient to have a width of zero, indicating a coefficient of `0`.

Decimal values that require more than 14 bytes can be encoded using the variable-length decimal opcode: `0xF6`.

A decimal with a coefficient of `-0` (which cannot be encoded in a `VarInt`) is encoded using opcode `6F`.

==== Example encoding of `0d0`
[source]
----
┌──── Opcode in range 60-6F indicates a decimal
│┌─── Low nibble 0 indicates a zero-byte
││    decimal; 0d0
60
----

==== Example encoding of `1.27`
[source]
----
┌──── Opcode in range 60-6F indicates a decimal
│┌─── Low nibble 2 indicates a 2-byte decimal
││
62 fd 7f
   │  └─── Coefficient: 1-byte FixedInt 127
   └────── Exponent: VarInt -2
----

==== Example variable-length encoding of `1.27`
[source]
----
┌──── Opcode F6 indicates a variable-length decimal
│
F6 05 fd 7f
   │  │  └─── Coefficient: 1-byte FixedInt 127
   │  └────── Exponent: VarInt -2
   └───────── Decimal length: VarUInt 2
----

==== Example variable-length encoding of `-0d3`
[source]
----
┌──── Opcode 6F indicates a variable-length decimal with a coefficient of -0
│
6F 03 03
   │  └────── Exponent: FixedInt 3
   └───────── Decimal length: VarUInt 1
----

[[timestamps]]
== Timestamps

NOTE: In Ion 1.0, text timestamp fields were encoded using the local time while binary timestamp fields were encoded
using UTC time. This required applications to perform conversion logic when transcribing from one format to the other.
*In Ion 1.1, all binary timestamp fields are encoded in local time.*

[[short_form_timestamp]]
=== Short-form timestamp

If an opcode has a high nibble of `0x7_`, it represents a short-form timestamp. This encoding focuses on making the
most common timestamp precisions and ranges the most compact; less common precisions can still be expressed via
the variable-length <<long_form_timestamp, long form timestamp>> encoding.

Timestamps may be encoded using the short form if they meet all of the following conditions:

* *The year is between 1970 and 2097*. The year subfield is encoded as the number of years since 1970. 7 bits are
dedicated to representing the biased year, allowing timestamps through the year 2097 to be encoded in this form.
* *The local offset is either UTC, unknown, or falls between `-14:00` to `+14:00` and is divisible by 15 minutes.* 7
bits are dedicated to representing the local offset as the number of quarter hours from -56 (that is: offset `-14:00`).
The value `0b1111111` indicates an unknown offset. At the time of this writing (2023-05T),
link:https://en.wikipedia.org/wiki/List_of_UTC_offsets[all real-world offsets fall between `-12:00` and `+14:00`].
* *The timestamp's fractional second precision (if present) is either 3 digits (milliseconds), 6 digits (microseconds),
or 9 digits (nanoseconds).*

The following letters to are used to denote bits in each subfield in diagrams that follow. Subfields occur in the same
order in all encoding variants, and consume the same number of bits, with the exception of the fractional bits, which
consume only enough bits to represent the fractional precision supported by the opcode being used.

[cols="^1, ^1, 4"]
|===
|Letter code | Number of bits | Subfield

| *Y*
| 7
| Year

| *M*
| 4
| Month

| *D*
| 5
| Day

| *H*
| 5
| Hour

| *m*
| 6
| Minute

| *o*
| 7
| Offset

| *U*
| 1
| Unknown or UTC offset

| *s*
|6
| Second

| *f*
| 10 (ms) +
20(μs) +
30(ns) +
| Fractional second

| *-*
| n/a
| Unused
|===

==== Opcode `0x70`: Year (1 byte)
[source]
----
+=========+
|YYYY:YYY-|
+=========+
----

==== Opcode `0x71`: Month (2 bytes)
[source]
----
+=========+=========+
|YYYY:YYYM|MMM-:----|
+=========+=========+
----

==== Opcode `0x72`: Day (2 bytes)
[source]
----
+=========+=========+
|YYYY:YYYM|MMMD:DDDD|
+=========+=========+
----

==== Opcode `0x73`: Hour+Minutes @ UTC or Unknown (4 bytes)

NOTE: Each encoding for a precision greater than or equal to `Hour+Minutes` comes in two flavors: one that uses a single
bit (`U`) to indicate UTC versus Unknown offset, and another that uses 7 bits (`o`) to encode the number of quarter-hours
offset from `-14:00`.

[source]
----
+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmU:----|
+=========+=========+=========+=========+
----

==== Opcode `0x74`: Hour+Minutes @ Offset (5 bytes)
[source]
----
+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmo:oooo|oo--:----|
+=========+=========+=========+=========+=========+
----

==== Opcode `0x75`: Seconds @ UTC or Unknown (5 bytes)
[source]
----
+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmU:ssss|ss--:----|
+=========+=========+=========+=========+=========+
----

==== Opcode `0x76`: Seconds @ Offset (5 bytes)
[source]
----
+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmo:oooo|oo--:----|
+=========+=========+=========+=========+=========+
----

==== Opcode `0x77`: Milliseconds @ UTC or Unknown (6 bytes)
[source]
----
+=========+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmk:ssss|ssff:ffff|ffff:----|
+=========+=========+=========+=========+=========+=========+
----

==== Opcode `0x78`: Milliseconds @ Offset (7 bytes)
[source]
----
+=========+=========+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmo:oooo|ooss:ssss|ffff:ffff|ff--:----|
+=========+=========+=========+=========+=========+=========+=========+
----

==== Opcode `0x79`: Microseconds @ UTC or Unknown (7 bytes)
[source]
----
+=========+=========+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmk:ssss|ssff:ffff|ffff:ffff|ffff:ff--|
+=========+=========+=========+=========+=========+=========+=========+
----

==== Opcode `0x7A`: Microseconds @ Offset (8 bytes)
[source]
----
+=========+=========+=========+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmo:oooo|ooss:ssss|ffff:ffff|ffff:ffff|ffff:----|
+=========+=========+=========+=========+=========+=========+=========+=========+
----

==== Opcode `0x7B`: Nanoseconds @ UTC or Unknown (8 bytes)
[source]
----
+=========+=========+=========+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmo:oooo|ooss:ssss|ffff:ffff|ffff:ffff|ffff:----|
+=========+=========+=========+=========+=========+=========+=========+=========+
----

==== Opcode `0x7B`: Nanoseconds @ Offset (8 bytes)
[source]
----
+=========+=========+=========+=========+=========+=========+=========+=========+
|YYYY:YYYM|MMMD:DDDD|HHHH:Hmmm|mmmo:oooo|ooss:ssss|ffff:ffff|ffff:ffff|ffff:----|
+=========+=========+=========+=========+=========+=========+=========+=========+
----

WARNING: Opcodes `0x7D`, `0x7E`, and `7F` are illegal; they are reserved for future use.

[[long_form_timestamp]]
=== Long-form timestamp

Unlike the <<short_form_timestamp, Short-form timestamp encoding>>, which is limited to encoding
timestamps in the most commonly referenced timestamp ranges and precisions for which it optimizes,
the long-form timestamp encoding is capable of representing any valid timestamp.

The long form begins with opcode `0xF7`. A <<varuint, `VarUInt`>> follows indicating the number
of bytes that were needed to represent the timestamp. The encoding consumes the minimum number
of bytes required to represent the timestamp. The declared length can be mapped to the timestamp’s
precision as follows:

[cols="^1, 6"]
|===
|Length | Corresponding precision

| 0
| illegal

| 1
| illegal

| 2
| Year

| 3
| Month or Day (see below)

| 4
| Illegal. The hour cannot be specified without also specifying minutes.

| 5
| Illegal

| 6
| Minutes

| 7
| Seconds

| 8 or more
| Fractional seconds
|===

Unlike the short-form encoding, the long-form encoding reserves:

* *14 bits for the year (`Y`)*, which is not biased.
* *12 bits for the offset*, which counts the number of minutes (not quarter-hours) from -1440
(that is: `-24:00`). An offset value of `0b111111111111` indicates an unknown offset.

If the timestamp's length is greater than or equal to `8`, it has fractional seconds that are encoded as a
`(coefficient, exponent)` pair, similar to a <<decimals, decimal>>. However, it is illegal for the fractional
seconds value to be greater than or equal to `1.0` or less than `0.0`. For this reason, both the exponent and
the coefficient are encoded using unsigned types. The included exponent `VarUInt` is implicitly negative, preventing
the encoding of decimal numbers greater than `1.0`. The coefficient `FixedUInt` is unsigned to prevent the encoding of
fractional seconds less than `0.0`. Note that validation is still required; namely:

* An exponent value of `0` is illegal, as that would result in a fractional seconds greater than `1.0` (a whole second).
* If `coefficient * 10^-exponent > 1.0`, that `(coefficient, exponent)` pair is illegal.

If the timestamp's length is `3`, the least significant bit in the final byte (`h`) is a flag
that indicates month (`0`) or day (`1`) precision.

==== Opcode `0xF7`: Long-form timestamp
[source]
----
     1         2         3         4         5         6         7       8         n
+=========+=========+=========+=========+=========+=========+=========+=======+   +=========+
|YYYY:YYYY|YYYY:YYMM|MMDD:DDDh|HHHH:mmmm|mmoo:oooo|oooo:ooss|ssss|----|VarUInt|...|FixedUInt|...
+=========+=========+=========+=========+=========+=========+=========+=======+   +=========+
----

[[text]]
== Text

[[strings]]
=== Strings

If the high nibble of the opcode is `0x8_`, it represents a string. The low nibble of the opcode
indicates how many UTF-8 bytes follow. Opcode 0x80 represents a string with empty text ("").

Strings longer than 15 bytes can be encoded with the `F8` opcode, which takes a <<varuint, `VarUInt`>>-encoded length
after the opcode.

==== Example encoding of the empty string (`""`)
[source]
----
┌──── Opcode in range 80-8F indicates a string
│┌─── Low nibble 0 indicates that no UTF-8 bytes follow
80
----

==== Example encoding of a 14-byte string
[source]
----
┌──── Opcode in range 80-8F indicates a string
│┌─── Low nibble E indicates that 14 UTF-8 bytes follow
││  f  o  u  r  t  e  e  n     b  y  t  e  s
8E 66 6f 75 72 74 65 65 6e 20 62 79 74 65 73
   └──────────────────┬────────────────────┘
                 UTF-8 bytes
----

==== Example encoding of a 24-byte string
[source]
----
┌──── Opcode F8 indicates a variable-length string
│  ┌─── Length: VarUInt 24
│  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     e  n  c  o  d  i  n  g
F8 31 76 61 72 69 61 62 6c 65 20 6c 65 6e 67 74 68 20 65 6e 63 6f 64 69 6e 67
      └────────────────────────────────┬────────────────────────────────────┘
                                  UTF-8 bytes
----

[[symbols_with_inline_text]]
=== Symbols with inline text

==== Example encoding of a symbol with empty text (`''`)
[source]
----
┌──── Opcode in range 90-9F indicates a symbol with inline text
│┌─── Low nibble 0 indicates that no UTF-8 bytes follow
90
----

==== Example encoding of a symbol with 14 bytes of inline text
[source]
----
┌──── Opcode in range 90-9F indicates a symbol with inline text
│┌─── Low nibble E indicates that 14 UTF-8 bytes follow
││  f  o  u  r  t  e  e  n     b  y  t  e  s
9E 66 6f 75 72 74 65 65 6e 20 62 79 74 65 73
   └──────────────────┬────────────────────┘
                 UTF-8 bytes
----

==== Example encoding of a symbol with 24 bytes of inline text
[source]
----
┌──── Opcode F9 indicates a variable-length symbol with inline text
│  ┌─── Length: VarUInt 24
│  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     e  n  c  o  d  i  n  g
F9 31 76 61 72 69 61 62 6c 65 20 6c 65 6e 67 74 68 20 65 6e 63 6f 64 69 6e 67
      └────────────────────────────────┬────────────────────────────────────┘
                                  UTF-8 bytes
----

[[symbols_with_symbol_table_addresses]]
=== Symbols with text in the symbol table

Symbol values whose text can be found in the local symbol table are encoded using opcodes `0xE1` through `0xE3`:

* `0xE1` represents a symbol whose address in the symbol table (aka its symbol ID) is a 1-byte
<<fixeduint, `FixedUInt`>> that follows the opcode.
* `0xE2` represents a symbol whose address in the symbol table is a 2-byte <<fixeduint, `FixedUInt`>> that follows
the opcode.
* `0xE3` represents a symbol whose address in the symbol table is a <<varuint,`VarUInt`>> that follows the opcode.

Writers MUST encode a symbol address in the smallest number of bytes possible. For each opcode above, the symbol
address that is decoded is biased by the number of addresses that can be encoded in fewer bytes.

[cols="^1a,1a,1a"]
|===
|Opcode |Symbol address range |Bias

|`0xE1`
|0 to 255
|0

|`0xE2`
|256 to 16,640
|256

|`0xE3`
|16,641 to infinity
|16,641
|===

[[binary_data]]
== Binary data

[[blobs]]
=== Blobs

Opcode `FE` indicates a blob of binary data.

==== Example encoding of a 24-byte blob
[source]
----
┌──── Opcode FE indicates a blob, VarUInt length follows
│   ┌─── Length: VarUInt 24
│   │
FE 31 49 20 61 70 70 6c 61 75 64 20 79 6f 75 72 20 63 75 72 69 6f 73 69 74 79
      └────────────────────────────────┬────────────────────────────────────┘
                            24 bytes of binary data
----


[[clobs]]
=== Clobs

Opcode `FF` indicates a clob--character data of an unspecified encoding.

==== Example encoding of a 24-byte clob
[source]
----
┌──── Opcode FF indicates a clob, VarUInt length follows
│   ┌─── Length: VarUInt 24
│   │
FF 31 49 20 61 70 70 6c 61 75 64 20 79 6f 75 72 20 63 75 72 69 6f 73 69 74 79
      └────────────────────────────────┬────────────────────────────────────┘
                            24 bytes of binary data
----

[[containers]]
== Containers

Each of the container types (list, s-expression, and struct) has both a length-prefixed encoding and a delimited
encoding.

The length-prefixed encoding places more burden on the writer, but simplifies reading and enables skipping
over uninteresting values in the data stream. In contrast, the delimited encoding is simpler and faster for
writers, but requires the reader to visit each child value in turn to skip over the container.

[[lists]]
=== Lists

==== Length-prefixed encoding

An opcode with a high nibble of `0xA_` indicates a length-prefixed list. The lower nibble of the
opcode indicates how many bytes were used to encode the child values that the list contains.

If the list's encoded byte-length is too large to be encoded in a nibble, writers may use the `0xFA` opcode
to write a variable-length list. The `0xFA` opcode is followed by a
<<varuint, `VarUInt`>> that indicates the list's byte length.

===== Example length-prefixed encoding of an empty list (`[]`)
[source]
----
┌──── An Opcode in the range 0xA0-0xAF indicates a list.
│┌─── A low nibble of 0 indicates that the child values of this list took zero bytes to encode.
A0
----

===== Example encoding of `[1, 2, 3]`
[source]
----
┌──── An Opcode in the range 0xA0-0xAF indicates a list.
│┌─── A low nibble of 0 indicates that the child values of this list took zero bytes to encode.
A6 51 01 51 02 51 03
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

===== Example encoding of `["variable length list"]`
[source]
----
┌──── Opcode 0xFA indicates a variable-length list. A VarUInt length follows.
│  ┌───── Length: VarUInt 22
│  │  ┌────── Opcode 0xF8 indicates a variable-length string. A VarUInt length follows.
│  │  │  ┌─────── Length: VarUInt 20
│  │  │  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     l  i  s  t
FA 2d F8 29 76 61 72 69 61 62 6c 65 20 6c 65 6e 67 74 68 20 6c 69 73 74
      └─────────────────────────────┬─────────────────────────────────┘
                          Nested string element
----

==== Delimited encoding

Opcode `0xF1` begins a delimited list, while opcode `0xF0` closes the most recently opened delimited container
that has not yet been closed.

===== Example delimited encoding of an empty list (`[]`)
[source]
----
┌──── Opcode 0xF1 indicates a delimited list
│  ┌─── Opcode 0xF0 indicates the end of the most recently opened container
F1 F0
----

===== Example encoding of `[1, 2, 3]`
[source]
----
┌──── Opcode 0xF1 indicates a delimited list
│                    ┌─── Opcode 0xF0 indicates the end of
│                    │    the most recently opened container
F1 51 01 51 02 51 03 F0
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

===== Example encoding of `[1, [2], 3]`
[source]
----
┌──── Opcode 0xF1 indicates a delimited list
│        ┌─── Opcode 0xF1 begins a nested delimited list
│        │        ┌─── Opcode 0xF0 closes the most recently
│        │        │    opened delimited container: the nested list.
│        │        │        ┌─── Opcode 0xF0 closes the most recently opened (and still open)
│        │        │        │    delimited container: the outer list.
│        │        │        │
F1 51 01 F1 51 02 F0 51 03 F0
   └─┬─┘    └─┬─┘    └─┬─┘
     1        2        3
----

[[s_expressions]]
=== S-expressions

==== Length-prefixed encoding

An opcode with a high nibble of `0xB_` indicates a length-prefixed S-expression. The lower nibble of the
opcode indicates how many bytes were used to encode the child values that the S-expression contains.

If the S-expression's encoded byte-length is too large to be encoded in a nibble, writers may use
the `0xFB` opcode to write a variable-length S-expression. The `0xFB` opcode is followed by a
<<varuint, `VarUInt`>> that indicates the S-expression's byte length.

===== Example length-prefixed encoding of an empty S-expression (`()`)
[source]
----
┌──── An Opcode in the range 0xB0-0xBF indicates an S-expression.
│┌─── A low nibble of 0 indicates that the child values of this S-expression took zero bytes to encode.
B0
----

===== Example encoding of `(1 2 3)`
[source]
----
┌──── An Opcode in the range 0xB0-0xBF indicates an S-expression.
│┌─── A low nibble of 6 indicates that the child values of this S-expression took six bytes to encode.
B6 51 01 51 02 51 03
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

===== Example encoding of `("variable length sexp")`
[source]
----
┌──── Opcode 0xFB indicates a variable-length list. A VarUInt length follows.
│  ┌───── Length: VarUInt 22
│  │  ┌────── Opcode 0xF8 indicates a variable-length string. A VarUInt length follows.
│  │  │  ┌─────── Length: VarUInt 20
│  │  │  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     s  e  x  p
FB 2d F8 29 76 61 72 69 61 62 6c 65 20 6c 65 6e 67 74 68 20 73 65 78 70
      └─────────────────────────────┬─────────────────────────────────┘
                          Nested string element
----

==== Delimited encoding

Opcode `0xF2` begins a delimited S-expression, while opcode `0xF0` closes the most recently opened
delimited container that has not yet been closed.

===== Example delimited encoding of an empty S-expression (`()`)
[source]
----
┌──── Opcode 0xF2 indicates a delimited S-expression
│  ┌─── Opcode 0xF0 indicates the end of the most recently opened container
F2 F0
----

===== Example encoding of `(1 2 3)`
[source]
----
┌──── Opcode 0xF2 indicates a delimited S-expression
│                    ┌─── Opcode 0xF0 indicates the end of
│                    │    the most recently opened container
F2 51 01 51 02 51 03 F0
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

===== Example encoding of `(1 (2) 3)`
[source]
----
┌──── Opcode 0xF2 indicates a delimited S-expression
│        ┌─── Opcode 0xF2 begins a nested delimited S-expression
│        │        ┌─── Opcode 0xF0 closes the most recently
│        │        │    opened delimited container: the nested S-expression.
│        │        │        ┌─── Opcode 0xF0 closes the most recently opened (and still open)
│        │        │        │    delimited container: the outer S-expression.
│        │        │        │
F2 51 01 F2 51 02 F0 51 03 F0
   └─┬─┘    └─┬─┘    └─┬─┘
     1        2        3
----

[[structs]]
=== Structs

Structs have 3 available encodings:

. <<structs_with_symbol_address_field_names, Structs with symbol address field names>>
. <<structs_with_varsym_field_names, Structs with `VarSym` field names>>
. <<delimited_structs, Delimited structs with `VarSym` field names>>

[[structs_with_symbol_address_field_names]]
==== Structs with symbol address field names

An opcode with a high nibble of `0xC_` indicates a struct with symbol address field names. The lower
nibble of the opcode indicates how many bytes were used to encode all of its nested `(field name, value)`
pairs.

If the struct's encoded byte-length is too large to be encoded in a nibble, writers may use the `0xFC` opcode
to write a variable-length struct with symbol address field names. The `0xFC` opcode is followed by a
<<varuint, `VarUInt`>> that indicates the byte length.

Each field in the struct is encoded as a <<varuint, `VarUInt`>> representing the address of the field name's
text in the symbol table, followed by an opcode-prefixed value.

===== Example encoding of an empty struct (`{}`)
[source]
----
┌──── An opcode in the range 0xC0-0xCF indicates a struct with symbol address field names
│┌─── A lower nibble of 0 indicates that the struct's fields took zero bytes to encode
C0
----

===== Example encoding of `{$10: 1, $11: 2}`
[source]
----
┌──── An opcode in the range 0xC0-0xCF indicates a struct with symbol address field names
│  ┌─── Field name: VarUInt 10 ($10)
│  │        ┌─── Field name: VarUInt 11 ($11)
│  │        │
C6 15 51 01 17 51 02
      └─┬─┘    └─┬─┘
        1        2
----

===== Example encoding of `{$10: "variable length struct"}`
[source]
----
 ┌───────────── Opcode `FC` indicates a variable length struct with symbol address field names
 │  ┌────────── Length: VarUInt 25
 │  │  ┌─────── Field name: VarUInt 10 ($10)
 │  │  │  ┌──── Opcode `F8` indicates a variable length string
 │  │  │  │  ┌─ VarUInt: 22 the string is 22 bytes long
 │  │  │  │  │  v  a  r  i  a  b  l  e     l  e  n  g  t  h     s  t  r  u  c  t
FC 33 15 F8 2D 76 61 72 69 61 62 6c 65 20 6c 65 6e 67 74 68 20 73 74 72 75 63 74
               └─────────────────────────────┬─────────────────────────────────┘
                                        UTF-8 bytes
----

[[structs_with_varsym_field_names]]
==== Structs with `VarSym` field names

NOTE: This encoding is very similar to <<structs_with_symbol_address_field_names, structs with symbol address
field names>>, but allows writers to choose between representing each field name as a symbol address
(for example: `$10`) or as inline UTF-8 bytes (for example: `"foo"`). This encoding is potentially less
dense, but offers writers significant flexibility over whether and when field names are added to the
symbol table.

An opcode with a high nibble of `0xD_` indicates a struct with <<varsym, `VarSym`>> field names. The lower
nibble of the opcode indicates how many bytes were used to encode all of its nested `(field name, value)`
pairs.

WARNING: Empty structs MUST be written using `0xC0`. `0xD0` is a reserved opcode.

If the struct's encoded byte-length is too large to be encoded in a nibble, writers may use the `0xFD` opcode
to write a variable-length struct with <<varsym, `VarSym`>> field names. The `0xFD` opcode is followed by a
<<varuint, `VarUInt`>> that indicates the byte length.

Each field in the struct is encoded as a  <<varsym, `VarSym`>> field name, followed by an
opcode-prefixed value.

===== Example encoding of `{"foo": 1, $11: 2}`
[source]
----
┌─── Opcode with high nibble `D` indicates a struct with VarSym field names
│┌── Length: 7
││ ┌─ VarSym -3      ┌─ VarSym: 11 ($11)
││ │   f  o  o       │
D9 FD 66 6F 6F 51 01 17 91 02
      └──┬───┘ └─┬─┘    └─┬─┘
      3 UTF-8    1        2
       bytes
----

// TODO: Demonstrate splicing macro values into the struct via VarSym escape code `0x00`.

[[delimited_structs]]
==== Delimited structs

Opcode `0xF3` indicates the beginning of a delimited struct with `VarSym` field names,
while opcode `0xF0` closes the most recently opened delimited container that has not yet been closed.

NOTE: There is no delimited encoding for structs with symbol address field names.

===== Example encoding of `{"foo": 1, $11: 2}`
[source]
----
┌─── Opcode 0xF3 indicates the beginning of a delimited struct with `VarSym` field names.
│
│  ┌─ VarSym -3      ┌─ VarSym: 11 ($11)
│  │                 │
│  │                 │         ┌─ Opcode 0xF0 indicates the end of the most
│  │   f  o  o       │         │  recently opened delimited container
F3 FD 66 6F 6F 51 01 17 91 02 F0
      └──┬───┘ └─┬─┘    └─┬─┘
      3 UTF-8    1        2
       bytes
----

[[nulls]]
=== Nulls

The opcode `0xEA` indicates an untyped null (that is: `null`, or its alias `null.null`).

The opcode `0xEB` indicates a typed null; a byte follows whose value indicates the type. The byte-to-type
mapping is as follows:

[cols="^1a,4a"]
|===
|Byte |Type

|`0x00`
|`null.bool`

|`0x01`
|`null.int`

|`0x02`
|`null.float`

|`0x03`
|`null.decimal`

|`0x04`
|`null.timestamp`

|`0x05`
|`null.string`

|`0x06`
|`null.symbol`

|`0x07`
|`null.clob`

|`0x08`
|`null.blob`

|`0x09`
|`null.list`

|`0x0A`
|`null.sexp`

|`0x0B`
|`null.struct`
|===

==== Example encoding of `null`
[source]
----
┌──── The opcode `0xEA` represents a null (null.null)
EA
----

==== Example encoding of `null.string`
[source]
----
┌──── The opcode `0xEB` indicates a typed null; a byte indicating the type follows
│  ┌──── Byte 0x05 indicates the type `string`
EB 0x5
----

[[annotations]]
=== Annotations

Annotations can be encoded either <<annotations_with_symbol_addresses, as symbol addresses>>
or <<annotations_with_varsym_text, as ``VarSym``s>>. In both encodings, the annotations sequence appears
just before the value that it decorates.

If an annotations sequence appears before one or more additional annotations sequences, the sequences
are concatenated.

It is illegal for an annotations sequence to appear before any of the following:

* The end of the stream
* A <<nops, `NOP`>>
// TODO: Links
* An E-expression (that is: a macro invocation). To add annotations to a macro invocation, see the
`annotate` macro.

If an annotations sequence appears before one or more additional annotations sequences, the sequences
are concatenated.

[[annotations_with_symbol_addresses]]
==== Annotations with symbol addresses
Opcodes `0xE4` through `0xE6` indicate one or more annotations encoded as symbol addresses. If the opcode is:

* `0xE4`, a single <<varuint, `VarUInt`>>-encoded symbol address follows.
* `0xE5`, two <<varuint, `VarUInt`>>-encoded symbol addresses follow.
* `0xE6`, a <<varuint, `VarUInt`>> follows that represents the number of bytes needed to encode
the annotations sequence, which can be made up of any number of `VarUInt` symbol addresses.

==== Example encoding of `$10::false`
[source]
----
┌──── The opcode `0xE4` indicates a single annotation encoded as a symbol address follows
│  ┌──── Annotation with symbol address: VarUInt 10
E4 15 5F
      └── The annotated value: `false`
----

==== Example encoding of `$10::$11::false`
[source]
----
┌──── The opcode `0xE5` indicates that two annotations encoded as symbol addresses follow
│  ┌──── Annotation with symbol address: VarUInt 10 ($10)
│  │  ┌──── Annotation with symbol address: VarUInt 11 ($11)
E5 15 17 5F
         └── The annotated value: `false`
----

==== Example encoding of `$10::$11::$12::false`
[source]
----
┌──── The opcode `0xE6` indicates a variable-length sequence of symbol address annotations;
│     a VarUInt follows representing the length of the sequence.
│   ┌──── Annotations sequence length: VarUInt 3 with symbol address: VarUInt 10 ($10)
│   │  ┌──── Annotation with symbol address: VarUInt 10 ($10)
│   │  │  ┌──── Annotation with symbol address: VarUInt 11 ($11)
│   │  │  │  ┌──── Annotation with symbol address: VarUInt 12 ($12)
E5 07 15 17 19 5F
               └── The annotated value: `false`
----

[[annotations_with_varsym_text]]
==== Annotations with `VarSym` text

Opcodes 0xE7 through 0xE9 indicate one or more annotations encoded as <<varsym, `VarSym`>>s.

If the opcode is:

* `0xE7`, a single `VarSym`-encoded symbol follows.
* `0xE8`, two `VarSym`-encoded symbols follow.
* `0xE9`, a `VarUInt` follows that represents the byte length of the annotations sequence, which is
made up of any number of annotations encoded as ``VarSym``s.

While this encoding is more flexible than <<annotations_with_symbol_addresses, annotations with
symbol addresses>>, it can be slightly less compact when all the annotations are encoded as symbol
addresses.

==== Example encoding of `$10::false`
[source]
----
┌──── The opcode `0xE7` indicates a single annotation encoded as a VarSym follows
│  ┌──── Annotation with symbol address: VarSym 10 ($10)
E7 15 5F
      └── The annotated value: `false`
----

==== Example encoding of `foo::false`
[source]
----
┌──── The opcode `0xE7` indicates a single annotation encoded as a VarSym follows
│  ┌──── Annotation: VarSym -3; 3 bytes of UTF-8 text follow
│  │   f  o  o
E7 FD 66 6F 6F 5F
      └──┬───┘ └── The annotated value: `false`
      3 UTF-8
       bytes
----

==== Example encoding of `$10::foo::false`

Note that `VarSym` annotation sequences can switch between symbol address and inline text
on a per-annotation basis.

[source]
----
┌──── The opcode `0xE8` indicates two annotations encoded as VarSyms follow
│  ┌──── Annotation: VarSym 10 ($10)
│  │  ┌──── Annotation: VarSym -3; 3 bytes of UTF-8 text follow
│  │  │   f  o  o
E8 15 FD 66 6F 6F 5F
         └──┬───┘ └── The annotated value: `false`
         3 UTF-8
          bytes
----

==== Example encoding of `$10::foo::$11::false`

[source]
----
┌──── The opcode `0xE9` indicates a variable-length sequence of VarSym-encoded annotations
│  ┌──── Length: VarUInt 6
│  │  ┌──── Annotation: VarSym 10 ($10)
│  │  │  ┌──── Annotation: VarSym -3; 3 bytes of UTF-8 text follow
│  │  │  │           ┌──── Annotation: VarSym 11 ($11)
│  │  │  │   f  o  o │
E9 0D 15 FD 66 6F 6F 17 5F
            └──┬───┘    └── The annotated value: `false`
            3 UTF-8
             bytes
----

[[nops]]
=== ``NOP``s

A `NOP` (short for "no-operation") is the binary equivalent of whitespace. `NOP` bytes have no meaning,
but can be used as padding to achieve a desired alignment.

An opcode of `0xEC` indicates a single-byte `NOP` pad. An opcode of `0xED` indicates that a
<<varuint, `VarUInt`>> follows that represents the number of additional bytes to skip.

==== Example encoding of a 1-byte `NOP`
[source]
----
┌──── The opcode `0xEC` represents a 1-byte NOP pad
│
EC
----

==== Example encoding of a 4-byte `NOP`
[source]
----
┌──── The opcode `0xED` represents a variable-length NOP pad; a VarUInt length follows
│  ┌──── Length: VarUInt 2; two more bytes of NOP follow
│  │
ED 05 93 C6
      └─┬─┘
NOP bytes, values ignored
----

